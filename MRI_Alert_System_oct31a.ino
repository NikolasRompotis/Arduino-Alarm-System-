#include "arduino_secrets.h"
/* 
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/0f985391-355d-426f-a7a0-ce6dea460cd2 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  String message;
  float ACCurrentValue;
  float Vo_Value;
  int temp1;
  int temp2;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"
#include <OneWire.h>
#include <DallasTemperature.h>
#include <MKRNB.h>

#define ONE_WIRE_BUS_1 2
#define ONE_WIRE_BUS_2 4
#define ACTectionRange 20
#define VREF  3.3

unsigned long previousOK;

unsigned long PrimaryTimerHigh;
unsigned long PTHCheck;

unsigned long PrimaryTimerLow;
unsigned long PTLCheck;

unsigned long SecondaryTimerHigh;
unsigned long STHCheck;

unsigned long SecondaryTimerLow;
unsigned long STLCheck;

unsigned long SwitchTimer;
unsigned long STCheck;

unsigned long PowerTimer;
unsigned long PTCheck;

const unsigned long OKinterval = 43200000;
unsigned long ProblemInterval = 3600000;
const unsigned long CheckInterval = 300000;

unsigned long y;

const float Vo = A1;
const float CurrentPin = A2;

float Vo_Val;
//float Vo_Value;

//int temp1;
//int temp2;

//!!! TEMPERATURE THRESHOLDS !!!
int temp1_low = 6;
int temp1_high = 14;
int temp2_low = 19;
int temp2_high = 24;

bool t1 = false;
bool t2 = false;
bool V = false;
bool C = false;
bool battery_check = false;
//String message;
char msg[200];
//TEMPERATURE SENSORS INITIALISATION
OneWire oneWire_one(ONE_WIRE_BUS_1);
OneWire oneWire_two(ONE_WIRE_BUS_2);

DallasTemperature primary_sensor(&oneWire_one);
DallasTemperature secondary_sensor(&oneWire_two);

//CURRENT READING
float readACCurrentValue() {
  float ACCurrtntValue = 0;
  float peakVoltage = 0;  
  float voltageVirtualValue = 0;  //Vrms
  for (int i = 0; i < 5; i++)
  {
    peakVoltage += analogRead(CurrentPin);   //read peak voltage
    delay(1);
  }
  peakVoltage = peakVoltage / 5;   
  voltageVirtualValue = peakVoltage * 0.707;
  voltageVirtualValue = (voltageVirtualValue / 1024 * VREF ) / 2;  

  ACCurrtntValue = voltageVirtualValue * ACTectionRange;

  return ACCurrtntValue;
}

//ΦΟΡΤΙΣΗ ΜΠΑΤΑΡΙΑΣ
const float maxVoltage = 4.2; // Fully charged battery voltage
const float minVoltage = 3.0; // Minimum safe operating voltage
float batper;
float BatteryPower(){
  // Read the analog voltage from the voltage divider
  
  float rawValue = analogRead(ADC_BATTERY);
  float voltage = (float)rawValue * (maxVoltage / 1023.0);

  // Calculate battery percentage based on voltage range
  float batteryPercentage = ((voltage - minVoltage)/(maxVoltage - minVoltage))*100.0;

  
  return batteryPercentage; 
}

void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500); 

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  
  
  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information you’ll get.
     The default is 0 (only errors).
     Maximum is 4
 */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
  
  pinMode(Vo, INPUT);
  pinMode(CurrentPin, INPUT);
  primary_sensor.begin();
  secondary_sensor.begin();
  

  delay(500);

  while ((!Serial.available()) or (!Serial)){
    if (millis() > 120000){
      break;
    }
  }

  if (Serial.available()){
    Serial.println("Δώστε κατώτατη τιμή πρώτου κατωφλίου: ");
    Serial.flush();
    temp1_low = Serial.parseFloat();
    Serial.flush();
    
    Serial.println("Δώστε ανώτατη τιμή πρώτου κατωφλίου: ");
    temp1_high = Serial.parseFloat();
    Serial.flush();
    
    Serial.println("Δώστε κατώτατη τιμή δεύτερου κατωφλίου: ");
    temp2_low = Serial.parseFloat();
    Serial.flush();

    Serial.println("Δώστε ανώτατη τιμή δεύτερου κατωφλίου: ");
    temp2_high = Serial.parseFloat();
    Serial.flush();

    
  }
  
  Serial.print("thresh 1: " );
  Serial.print(temp1_low);
  Serial.print(" - ");
  Serial.println(temp1_high);
  Serial.print("thresh 2: ");
  Serial.print(temp2_low);
  Serial.print(" - ");
  Serial.println(temp2_high);
  
  
}

void loop() {
  ArduinoCloud.update();
  // Your code here 
  unsigned long startTime = millis();
  ACCurrentValue = readACCurrentValue(); // ΑΝΑΓΝΩΣΗ ΤΙΜΗΣ ΡΕΥΜΑΤΟΣ
  Vo_Val = analogRead(Vo); //ΑΝΑΓΝΩΣΗ ΑΝΑΛΟΓΙΚΗΣ ΤΑΣΗΣ ΣΤΟΝ ΔΙΑΚΟΠΤΗ
  Vo_Value = Vo_Val * 3.3/1023; 

  //ΑΝΑΓΝΩΣΗ ΘΕΡΜΟΚΡΑΣΙΩΝ
  primary_sensor.requestTemperatures();
  secondary_sensor.requestTemperatures();
  delay(50);
  temp1 = primary_sensor.getTempCByIndex(0);
  temp2 = secondary_sensor.getTempCByIndex(0);
  
  //12 HOUR CHECK
  if ((temp1_low <= temp1 <= temp1_high) and (temp2_low <= temp2 <= temp2_high) and (Vo_Value <= 1) and (abs(ACCurrentValue) > 0.20) and (abs(startTime-previousOK) >= OKinterval)) {
    /*
    Serial.println("All OK");
    */
    batper = BatteryPower();
    message = String("All OK\n") + "Battery: " + String(batper) +"%";
    message.trim();
    
    Serial.print("msg is: ");
    Serial.println(message);
    
    previousOK = startTime;
  }
//PRIMARY WATER CHECK
  if (temp1 > temp1_high and t1 == false) {
    /*
    Serial.print("PRIMARY WATER HIGH TEMP: ");
    */
    Serial.println(temp1);
    
    batper = BatteryPower();
    message = "PRIMARY WATER HIGH TEMPERATURE: " + String(temp1) +"\n" + "Battery: " + String(batper) + "%";
    message.trim();
    
    Serial.print("msg is: ");
    Serial.println(message);
    
    
    
    t1 = true;
    PTHCheck = startTime;
  }
  if (temp1 > temp1_high and abs(startTime - PrimaryTimerHigh) >= ProblemInterval and t1 == true and abs(startTime - PTHCheck) >= CheckInterval) {
    /*
    Serial.print("PRIMARY WATER HIGH TEMP: ");
    */
    Serial.println(temp1);
    
    batper = BatteryPower();
    message = "PRIMARY WATER HIGH TEMPERATURE: " + String(temp1) +"\n" + "Battery: " + String(batper) + "%";
    message.trim();
    
    Serial.print("msg is: ");
    Serial.println(message);
    
    
    PrimaryTimerHigh = startTime;
  }
  if (temp1 < temp1_low and t1 == false){
    /*
    Serial.print("PRIMARY WATER TEMP LOW: ");
    */
    Serial.println(temp1);
    
    batper = BatteryPower();
    message = "PRIMARY WATER LOW TEMPERATURE: " + String(temp1) + "\n" + "Battery: " + String(batper) + "%";
    message.trim();
    message.toCharArray(msg, 200);
    Serial.print("msg is: ");
    Serial.println(message);
    
    t1 = true;
    PTLCheck = startTime;
  }
  if (temp1 < temp1_low and abs(startTime - PrimaryTimerLow >= ProblemInterval) and t1 == true and abs(startTime - PTLCheck) >= CheckInterval){
    /*
    Serial.print("PRIMARY WATER TEMP LOW: ");
    */
    Serial.println(temp1);
    
    batper = BatteryPower();
    message = "PRIMARY WATER LOW TEMPERATURE: " + String(temp1) + "\n" + "Battery: " + String(batper) + "%";
    message.trim();
    message.toCharArray(msg, 200);
    Serial.print("msg is: ");
    Serial.println(message);
    
    
    PrimaryTimerLow = startTime;
  }
  
  if ((temp1_low <= temp1 and temp1 <= temp1_high) and t1 == true){
    /*
    Serial.print("PRIMARY WATER TEMPERATURE RESTORED: ");
    */
    Serial.println(temp1);
    
    Serial.print("Temp1: ");
    Serial.println(temp1);
    batper = BatteryPower();
    message = "PRIMARY WATER TEMPERATURE RESTORED: " + String(temp1) + "\n" + "Battery: " + String(batper) + "%";
    message.trim();
    message.toCharArray(msg, 200);
    Serial.print("msg is: ");
    Serial.println(message);
    
    t1 = false;
  }
//SECONDARY WATER CHECK
  if (temp2 > temp2_high and t2 == false) {
    /*
    Serial.print("SECONDARY WATER HIGH TEMP: ");
    */
    Serial.println(temp2);
    
    batper = BatteryPower();
    message = "SECONDARY WATER TEMPERATURE HIGH: " + String(temp2) + "\n" + "Battery: " + String(batper) + "%";
    message.trim();
    message.toCharArray(msg, 200);
    Serial.print("msg is: ");
    Serial.println(message);
    
    t2 = true;
    STHCheck = startTime;
  }
  if (temp2 > temp2_high and abs(startTime - SecondaryTimerHigh >= ProblemInterval) and t2 == true and abs(startTime - STHCheck) >= CheckInterval) {
    /*
    Serial.print("SECONDARY WATER HIGH TEMP: ");
    */
    Serial.println(temp2);
    
    batper = BatteryPower();
    message = "SECONDARY WATER TEMPERATURE HIGH: " + String(temp2) + "\n" + "Battery: " + String(batper) + "%";
    message.trim();
    message.toCharArray(msg, 200);
    Serial.print("msg is: ");
    Serial.println(message);
    
    
    SecondaryTimerHigh = startTime;
  }
  if (temp2 < temp2_low and t2 == false){
    /*
    Serial.print("SECONDARY WATER TEMP LOW: ");
    */
    Serial.println(temp2);
    
    batper = BatteryPower();
    message = "SECONDARY WATER TEMPERATURE LOW: " + String(temp2) +"\n" + "Battery: " + String(batper) + "%";
    message.trim();
    message.toCharArray(msg, 200);
    Serial.print("msg is: ");
    Serial.println(message);
    
    t2 = true;
    STLCheck = startTime;
  }
  if (temp2 < temp2_low and abs(startTime - SecondaryTimerLow >= ProblemInterval) and t2 == true and abs(startTime - STLCheck) >= CheckInterval){
    /*
    Serial.print("SECONDARY WATER TEMP LOW: ");
    */
    Serial.println(temp2);
    
    batper = BatteryPower();
    message = "SECONDARY WATER TEMPERATURE LOW: " + String(temp2) +"\n" + "Battery: " + String(batper) + "%";
    message.trim();
    message.toCharArray(msg, 200);
    Serial.print("msg is: ");
    Serial.println(message);
    
    
    SecondaryTimerLow = startTime;
  }
  if ((temp2_low <= temp2 and temp2 <= temp2_high) and t2 == true){
    /*
    Serial.print("SECONDARY WATER TEMPERATURE RESTORED: ");
    */
    Serial.println(temp2);
    
    batper = BatteryPower();
    message = "SECONDARY WATER TEMPERATURE RESTORED: " + String(temp2) +"\n" + "Battery: " + String(batper) + "%";
    message.trim();
    message.toCharArray(msg, 200);
    Serial.print("msg is: ");
    Serial.println(message);
    
    t2 = false;
  }

  //SWITCH CHECK
  if (Vo_Value >= 2.5 and V==false){
    /*
    Serial.println("COMPRESSOR FAULT ");
    */
    Serial.println(Vo_Value);
    batper = BatteryPower();
    message = String("COMPRESSOR FAULT\n") + "Battery: " + String(batper) + "%";
    message.trim();
    message.toCharArray(msg, 200);
    Serial.print("msg is: ");
    Serial.println(message);
    
    V = true;
    STCheck = startTime;
  }
  if (Vo_Value >= 2.5 and abs(startTime - SwitchTimer) >= ProblemInterval and V==true and abs(startTime - STCheck) >= CheckInterval){
    /*
    Serial.println("COMPRESSOR FAULT ");
    */
    Serial.println(Vo_Value);
    batper = BatteryPower();
    message = String("COMPRESSOR FAULT\n") + "Battery: " + String(batper) + "%";
    message.trim();
    message.toCharArray(msg, 200);
    Serial.print("msg is: ");
    Serial.println(message);
    
    
    SwitchTimer = startTime;
  }
  if ((Vo_Value <=1) and V == true){
    /*
    Serial.println("NORMAL COMPRESSOR RUN ");
    */
    Serial.println(Vo_Value);
    batper = BatteryPower();
    message = String("NORMAL COMPRESSOR RUN\n") + "Battery: " + String(batper) + "%";
    message.trim();
    message.toCharArray(msg, 200);
    Serial.print("msg is: ");
    Serial.println(message);
    
    V = false;
  }

  //POWER CHECK
  
  while (ACCurrentValue <= 0.1){
    delay(25);
    ACCurrentValue = readACCurrentValue();
    if (ACCurrentValue <= 0.5 and C == false){
      /*
      Serial.println("COMPRESSOR POWER FAULT");
      */
      Serial.println(ACCurrentValue);

      batper = BatteryPower();
      message = String("COMPRESSOR POWER FAULT\n") + "Battery: " + String(batper) + "%";
      message.trim();
      message.toCharArray(msg, 200);
      Serial.print("msg is: ");
      Serial.println(message);
      
      C = true;
      PTCheck = startTime;
    }
    
    if (ACCurrentValue <= 0.5 and abs(startTime - PowerTimer) >= ProblemInterval and C == true and abs(startTime - PTCheck) >= CheckInterval){
      /*
      Serial.println("COMPRESSOR POWER FAULT");
      */
      Serial.println(ACCurrentValue);

      batper = BatteryPower();
      message = String("COMPRESSOR POWER FAULT\n") + "Battery: " + String(batper) + "%";
      message.trim();
      message.toCharArray(msg, 200);
      Serial.print("msg is: ");
      Serial.println(message);
      
      
      PowerTimer = startTime;
      break;
    }
    
  }
  if ((ACCurrentValue > 0.5) and C == true){
    /*
    Serial.print("COMPRESSOR POWER RESTORED");
    */
    Serial.println(ACCurrentValue);

    batper = BatteryPower();
    message = String("COMPRESSOR POWER RESTORED\n") + "Battery: " + String(batper) + "%";
    message.trim();
    message.toCharArray(msg, 200);
    Serial.print("msg is: ");
    Serial.println(message);
    
    C = false;
  }

  if (millis() >= 3600000){
    ProblemInterval = 3600000;
  }
  else {
    ProblemInterval = 600000;
  }

  //BATTERY CHANGE CHECK
  batper = BatteryPower();
  
  if (batper <= 15.0 and  battery_check == false){
    message = "Low Battery: " + String(batper) + "%";
    
    battery_check = true;
  }
  if (batper <= 15.0 and battery_check == true){
    y++;
  }
  if (y >= 7200000){
    message = "Battery Low: " + String(batper) + "%" + "and not charging. Battery change might be needed.";
    
  }
  if (batper > 15.0){
    y = 0;
    battery_check = false;
  }
}






/*
  Since Temp1Low is READ_WRITE variable, onTemp1LowChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onTemp1LowChange()  {
  // Add your code here to act upon Temp1Low change
}

/*
  Since Temp1High is READ_WRITE variable, onTemp1HighChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onTemp1HighChange()  {
  // Add your code here to act upon Temp1High change
}





